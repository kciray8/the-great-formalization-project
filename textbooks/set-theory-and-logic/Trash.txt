Ltac repl_fix eq_hyp target_hyp f :=
let symmetric_eq := fresh "symmetric_eq" in
let target_hyp_repl := fresh target_hyp in
match type of eq_hyp with
| eq ?a ?b =>
match type of target_hyp with
|context g[ b ] => 
let my_func := (context g [a]) in 
pose proof eq_symm _ _ eq_hyp as symmetric_eq;
pose proof (eq_subs f
b a symmetric_eq target_hyp) : my_func as target_hyp_repl;
clear symmetric_eq
|context g[ a ] => 
let my_func := (context g [b]) in 
pose proof (eq_subs f
a b eq_hyp target_hyp) : my_func as target_hyp_repl
| _ => fail "error inside nested matches"
end
end.


(* Theorem 5.2 - 7 - reusing*)
Lemma one_set_is_complement_of_another_reusing: ∀U. 
∀A. ∀B. (A ⊆ U) -> (B ⊆ U) -> 
((((A ∪ B) = U) ∧ ((A ∩ B) = ∅)) -> B = (U - A)).
intros U A B u1 u2 H.
both H.
(* seems impossible*)
Admitted.

(* Theorem 5.2 - 8 - reusing*)
Lemma double_complement_reusing: ∀U. ∀A. (A ⊆ U) -> (U - (U - A)) = A.
intros U A H.
take union_with_complement A.
(* seems impossible*)
Admitted.

(* Theorem 5.2 - 9 - reusing*)
Lemma complement_of_empty_set_reusing: 
∀U. (U - ∅) = U.
(* seems impossible*)
Admitted.

(* Theorem 5.2 - 10 - reusing*)
Lemma union_idempotent_reusing: ∀A. ((A ∪ A) = A).
intros A.
take empty_set_absorption A.
take intersection_with_complement A A (subset_refl A).
repl <- H0 in H.
take union_intersection_distr A A (A - A).
repl H1 in H.
take union_with_complement A A (subset_refl A).
repl H2 in H.


(* Theorem 5.2 - 11 - reusing*)
Lemma union_with_universal_set_reusing: ∀A. ∀U.
(A ⊆ U) -> ((A ∪ U) = U).

(* Theorem 5.2 - 12 - reusing*)
Lemma absorption_law_union_intersection_reusing: ∀A. ∀B. ((A ∪ (A ∩ B)) = A).


Definition pair_e (a b: Set) := 
∃1u. unit_set_p a u ∧
∃1ab. pair_unord_p a b ab ∧
∃1s. pair_unord_p u ab s.

Definition pair_e_exists(a b: Set) : (pair_e a b).
unfold pair_e.
ex_unique_in (unit_set_exists a).
ex_unique_in (pair_unord_exists a b).
take pair_unord_exists u ab.
ex_el H.
split.
apply (ex_in _ p).
apply H.
apply any_biimpl_set_is_no_more_than_one.
Qed.



Definition pair_p_join(a b p1 p2: Set):
(pair_p a b p1) -> (pair_p a b p2) -> p1 = p2.
intros H1 H2.
unfold pair_p in H1, H2.
ex_el H1.
ex_el H2.
clear U U0.
right H1.
right H2.
ex_el H.
ex_el H0.
right H.
left H1.
left H2.
take extension_trans _ _ _ H4 H5.
repl H6 in H3.
pose proof H3.
left H.
left H0.
take extension_trans _ _ _ H8 H9.
right H0.
repl H10 in H7.
take extension_trans _ _ _ H7 H11.
apply H12.
Qed.


Local Definition ex_via_all {T: Type} (P: T->Prop) := ¬ all (fun x => ¬ (P x)).

Local Notation "'∃2' x . p" := (ex_via_all (fun x => p))
  (at level 200, x binder, right associativity).

Local Definition ex2_in {T: Type} (P: T->Prop) (u: T) (v: P u): ∃2 x . P x.
unfold ex_via_all.
intro.
pose proof H u.
pose proof H0 v.
apply H1.
Qed.

Local Definition ex2_el (P: Set->Prop) (u: (∃2 x . P x)) 
(A: Prop) (v : ∀x. (P x ⇒ A)): A.
unfold ex_via_all in u.
apply DN_el.
intro.
apply u.
intro x.
pose proof v x.
pose proof contrapositive H0.
apply H1.
apply H.
Qed.


Theorem downgrade_ex_unique_with_biimp_and_conj (P Q: Set->Prop):
(∃x. (∀ z . z ∈ x ⇔ P z) ∧ Q x) -> (∃1 x. (∀ z . z ∈ x ⇔ P z) ∧ Q x).
intro.
intro.
split.
apply H.
apply ex_less_conj_in.
apply any_biimpl_set_is_no_more_than_one.
Qed.

(*Definition is_equivalence_class A p X (p_is_rel: relation_p p) := 
∀x::X. ∃1u_x. unit_set_p x u_x ∧ p_relatives_p u_x p A p_is_rel.*)



(*Theorem check_equivalence_class_p p X A (ER: equivalence_relation p X): 
(equivalence_class_p p X A ER) ⇔ (equivalence_class_p_alt p X A ER).
unfold equivalence_class_p.
unfold equivalence_class_p_alt.
split.
intro.
left H.
split.
apply H0.
right H.
ex_el H1.
both H1.
ex_in x.
split.
apply H2.
ex_unique_in (unit_set_exists x).
unfold p_relatives_p.
intro.
split.
intro.
ex_in x.
split.
take P x.
right H4.
apply H5.
apply eq_refl.
ex_el H3.
both H3.
take H4 x0.
repl H5 in H2.
repl <- H5 in H3.
left H3 H1.
apply H6.
intro.
ex_el H1.
both H1.
*)

Theorem range_of_cartesian: ∃1e. (empty_set_p e) ∧ ∀X. ∀Y. 
∃1c. (cartesian_old_p X Y c) ∧ 
∃1r. (range_p c r) ∧ ((X ≠ e) -> (r = Y)).
ex_unique_in empty_set_exists.
intros X Y.
ex_unique_in (cartesian_exists_old X Y).
assert (relation c).
unfold relation.
intros x x_in_c.
take P0 x.
left H.
take H0 x_in_c.
ex_el H1.
both H1.
ex_el H3.
both H3.
apply (ex_in _ x0).
apply (ex_in _ y).
apply H4.
ex_unique_in (range_exists c H).
intro.
eq_in.
take P1 x.
left H2.
take H3 H1.
ex_el H4.
take P0 (< x0, x >).
left H5.
take H6 H4.
ex_el H7.
both H7.
ex_el H9.
both H9.
take pair_property H10.
both H9.
repl H12.
apply H7.
take P1 x.
right H2.
apply H3.
clear H2 H3.
rename x into y.
take non_empty_set_has_element2.
left H2.
clear H2.
ex_el H3.
both H3.
take H4 X.
clear H4.
assert (X ≠ x).
intro.
repl H4 in H0.
apply H0.
eq_in.
take H2 x0.
left H6.
apply (H7 H5).
take P x0.
left H6.
apply (H7 H5).
take H3 H4.
change (∃ x . x ∈ X) in H5.
ex_el H5.
take P0 (< x0, y >).
apply (ex_in _ x0).
right H6.
apply H7.
apply (ex_in _ x0).
split.
ass.
apply (ex_in _ y).
split.
ass.
apply eq_refl.
Qed.


Definition restriction_check (f X Y A: Set) (H1: on_into f X Y) 
(H2: A ⊆ X) (g: Set):=
∃1AxY. cartesian_p A Y AxY ∧ (intersection2_p f AxY g).



Definition restriction_p (f X Y A: Set) (H1: on_into f X Y) (fA: Set) :=
function_on fA A ∧ ∀a::A. 
(∃1y1. appl_p fA a Y y1 ∧
∃1y2. appl_p f a Y y2 ∧ y1 = y2).

Definition restriction_exists (f X Y A: Set) (H1: on_into f X Y) (H2: A ⊆ X): 
∃1g. restriction_p f X Y A H1 g.
Admitted.






Definition restriction_legacy (f X Y A: Set) (H1: on_into f X Y) 
(H2: A ⊆ X) (g: Set):=
∃1AxY. cartesian_p A Y AxY ∧ (intersection2_p f AxY g).

Definition restriction_legacy_is_into (f X Y A: Set) (H1: on_into f X Y) 
(H2: A ⊆ X) (g: Set) (H3: restriction_legacy f X Y A H1 H2 g): on_into g A Y.
unfold restriction_legacy in H3.
ex_el H3.
both H3.
split.
split.
split.
intro x.
intro.
take H0 x.
left H4 H3.
right H5.
take element_of_cartesian_is_ordered_pair A Y AxY x H H6.
apply H7.
intros x y z.
ex_unique_in (pair_exists x y).
ex_unique_in (pair_exists x z).
intro.
both H3.
take H0 xy.
left H3 H4.
both H6.
take H0 xz.
left H6 H5.
both H9.
left H1.
left H9.
right H12.
take H13 x y z.
ex_el H14.
both H14.
ex_el H16.
both H16.
apply H17.
join H15 P.
repl H16.
join H14 P0.
repl H18.
split.
ass.
ass.
intro k.
split.
intro.
take H2 k H3.
left H1.
right H5.
unfold domain_p in H6.
take H6 k.
left H7 H4.
ex_el H8.
ex_el H8.
both H8.
ex_in y.
split.
ex_in xy.
split.
apply H9.
take H0 xy.
apply_b H8.
split.
ass.
take pair_components_are_in_domain_and_codomain k y.
ex_el H8.
both H8.
join H11 H9.
repl H8 in H12.
take H12 f X Y H1 H10.
both H13.
take H xy.
apply_b H13.
ex_in k.
split.
apply H3.
ex_in y.
split.
apply H15.
split.
ex_in xy.
split.
apply H9.
apply eq_refl.
apply ex_less_conj_in.
apply any_biimpl_set_is_no_more_than_one.
apply ex_less_conj_in.
apply any_biimpl_set_is_no_more_than_one.
intro.
ex_el H3.
ex_el H3.
both H3.
take H0 xy.
left H3 H5.
both H6.
take H xy.
left H6 H8.
ex_el H9.
both H9.
ex_el H11.
both H11.
ex_el H12.
both H12.
repl <- H13 in H11.
take pair_property_p k y x y0 xy H4 H11.
both H12.
repl H14.
apply H10.
unfold range_is_subset.
ex_unique_in (range_exists g).
intro u.
intro.
take P u.
left H4 H3.
rename u into y.
ex_el H5.
ex_el H5.
both H5.
take H0 xy.
left H5 H7.
both H8.
take H xy.
left H8 H10.
ex_el H11.
both H11.
ex_el H13.
both H13.
ex_el H14.
both H14.
repl <- H15 in H13.
take pair_property_p x y x0 y0 xy H6 H13.
both H14.
repl H17.
apply H11.
Qed.

(* skipped boring stuff *)

Definition appl(f x: Set) (P: Set -> Prop) :=
∃1y. appl_p f x y ∧ (P y).


Definition restriction_to_subset_of_domain (f g Y A: Set) 
(F1: function f) (F2: function g): 
∃1Dg. domain_p g Dg ∧
∃1Df. domain_p f Df ∧
((A ⊆ Df) ->
((restriction_p f A Y g)⇔(Dg ⊆ Df ∧ ∀x::Dg. 
(∃1y1. appl_p f x y1 ∧ ∃1y2. appl_p g x y2 ∧ y1 = y2)))).
ex_unique_in (domain_exists g).
ex_unique_in (domain_exists f).
intro.
split.
intro.
split.
intro k.
intro.
assert (function_on f Df).
split.
apply F1.
apply P0.
assert (function_on g Dg).
split.
apply F2.
apply P.
take appl_exists g Dg H3 k H1.
ex_el H4.
unfold appl_p in H4.
ex_el H4.
both H4.
take H k.
apply H4.
take H0 p.
left H7 H6.
both H8.
ex_el H10.
both H10.
ex_el H11.
both H11.
join_pairs_by_name H5 H12.
repl H11.
apply H8.
intro.
intro.
assert (function_on g Dg).
split.
apply F2.
apply P.
take appl_exists g Dg H2 x H1.
assert (function_on f Df).
split.
apply F1.
apply P0.
take appl_exists f Df H4.
assert (x ∈ Df).
take H x.
apply H6.
take H0 x.


ex_unique_in H3.